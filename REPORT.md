# Отчет

| Лабораторная работа №1 | M3102 | АОВС |
| ---------------------- | ----------- | ---- |
| Представление чисел    | Алехина Ксения Степановна      | 2024 |

## Инструментарий

> С++20

## Вариант

> Выполнена normal версия, обе фиксированная и плавающая точки

## Результат работы на тестовых данных: <https://github.com/skkv-itmo-comp-arch/se-comp-arch24-fixed-floating-kaleh1na/actions/runs/8097542906>

## Описание

# Фиксированная точка

Программа для работы с числами в формате фиксированной точке была реализована с помощью класса **FixedPointArithmetic**.

## Класс FixedPointArithmetic

### Поля класса

* **number1** и **number2** - входные числа, которые мы храним в формате uint32_t в представлении в дополнительном коде
  > формата uint32_t достаточно, т.к A + B <= 32, соответственно число будет занимать максимум 32 бита
* **integer_size** и **fractional_size** - количество битов на целую и дробную чатсь соотвественно
* **rounding_type** - тип округления
* **operation** - операция, которую нужно применить к входным числам. По дефолту стоит '=', сделано для удобства - данная операция означает "вывести входное число"

### Методы класса

#### Методы для парсинга

* **HexToInt** - вспомогательный метод, повзоляющий перевести входное число из 16-чной системы счисления в 10-чную 
  > Был *специально* реализован собственный метод, например, чтобы обработать ситуации по типу переполнения - библиотечные функции обычно кидают исключение при переполнении, однако если нам на вход пришло слишком много битов - мы должны просто взять последние A + B. Для этого мы, во-первых, считываем у входного числа только последние 8 знаков (8 знаков в 16-чке = 32 знакам в 2-чке), во-вторых, применяем функцию *Module* - функция для выполнения модулярной арифметики, будет рассмотрена ниже. Так же данный метод обрабатывает такие ситцации, как некорректный знак или же полностью неверный формат входного числа.

* **ReadFormat** - функция, которая из аргумента вида А.B достает значения размера фиксированной и дробной части и записывает их в поля класса integer_size и fractional_size.

* **Parse** - основной метод парсинга. Записывает всю информацию в поля класса. При любом исключении возвращает false, после чего выходит из функции. В main() если Parse вернул false в поток ошибок выводится "Invalid argument" и программа завершается с ненулевым кодом.
  > Parse обрабатывает множество ситуаций неверно поданных на вход аргументов. Это было сделано для уменьшения вероятности падения программы и для удобства тестирования. Например, усли формат вводных данных не соответствует одному из 
  > * <формат> <округление> <число>
  > * <формат> <округление> <число1> <операция> <число2>
  >
  > Или если была подана неверная операция(не соответствует ни одной из списка "+, -, *, /"), или же неверный формат округления (должен быть строго либо 0, либо 1, либо 2, либо 3), и т.д

#### Методы для работы с числами

* **Округление** - метод **Round**.
  Метод Round принимает на вход ссылку на number - **модуль** числа, которое требует округления, divider - делитель, is_negative - флаг, которые показывает отрицательное или положительное(нужен, так как знак числа влияет в случае направленного округления)

  Находим и запоминаем remainder - остаток при делении number на divider, после делим number на divider. 

  В зависимости от получившегося остатка:
  
  - если остаток равен нулю, округление не требуется
  - если остаток не равен нулю, смотрим на тип округления:
  > * 0 - округление к нулю - означает, что мы просто обрезаем нецелые разряды - в данном случае нам ничего не нужно делать, так как целочисленное деление number на divider уже округлило результат к нулю
  >> * 12.45 -> 12
  >> * -14.99 -> -14
  > * 1 - округление к ближайшему четному - заметим, что узнать к какому числу ближе дробная часть мы можем с помощью того, что мы запомнили остаток - по сути, наша дробная округляемая часть выглядит как дробь remainder/divider, если remainder/divider > 1/2, т.е remainder * 2 > divider, то наше число ближе к большему по модулю числу из промежутка. В данном случае добавляем единицу к number. Если же remainder * 2 < divider - число ближе к наименьшему по модулю, единицу прибавлять не нужно. В случае если remainder * 2 = divider, число находится точно в центре промежутка, посередине. Тогда смотрим на четность последнего текущего разряда в number, и если он нечетный округляем к наибольшему по модулю, т.е добавляем единицу.
  >> * 12 3/4, 3 * 2 > 4 -> 12 + 1 = 13
  >> * 140 11/23, 11 * 2 < 23 -> 140
  >> * -131 10/20, 10 * 2 = 20 -> 131 % 10 = 1 - нечетное -> 131 + 1 = 132 -> -132
  > * 2 - округление к плюс бесконечности: здесь, если число положительное, мы округляем вверх(всегда прибавляем единицу), если же число отрицательное, всегда округляем к нулю(срезаем разряды)
  >> * -12.32 -> -12
  >> * 12.32 -> 13
  > * 3 - округление к минус бесконечности - по аналогии с предыдущим, но наоборот
  >> * -12.32 -> -13
  >> * 12.32 -> 12

  Реализовано с помощью switch-case.

* **Модулярная арифметика** - метод **Module** 
  В результате операций может возникнуть переполнение числа, выход за рамки назначенного формата (integer_size + fractional_size) битов. В таком случае, берем остаток по модулю от 2 в степени (integer_size + fractional_size).

* Смена знака в доп. коде - метод **Negation**
Во время выполнения программы иногда требуется работать с числом по модулю, например в умножении и делении, выводе числа - данный метод меняет знак в доп. коде. 

> Заметим, что противоположные числа записанные в uint-aх в доп. коде дают в сумме размер диапазона всех представимых в данном формате чисел, а именно  range = 2 в степени (integer_size + fractional_size) = (uint64_t)1 << (integer_size + fractional_size).
> > Здесь и далее при сдвигах единицы для получения степени двойки кастим ее к uint64_t, тк если этого не сделать, может случиться переполнение типа uint32_t.
> 
> Кроме нуля - противоположное к нулю  число - это сам нуль, вынесем этот случай в отдельный if, для остальных случах будем искать противоположное методом вычитания значения числа из range.

#### Методы для выполнения операций

* **DoOperation** - менеджер программы, с помощью switch case выполняет нужную операцию самостоятельно(сложение, вычитание) или же обращается к вспомогательной функции(умножение, деление). В конце берет получившийся результат по модулю(модулярная арифметика) с помощью функции Module и выводит число с помощью функции PrintNumber.

Рассмотрим логику выполнения операций:

* **Сложение**
 Досталось дешево засчет использования встроенного типа uint32_t, числа в фиксированной точке в данном типе данных складываются самостоятельно, в том числе самостоятельно работает с доп. кодом
* **Вычитание** 
 Реализовано через сложение с противоположным числом(преимущества использования доп. кода). Для этого второе число переводим с помощью функции Negation и складываем с первым.

 > В сложении и вычитании может произойти переполнение - для этого выполняем модулярную арифметику, она выполняется после операции и перед выводом в функции DoOperation

 * **Умножение**
  Для начала, запоминаем, какой знак должен быть у получившегося числа, а вводные два числа переводим в положительные если они являются отрицательными, иначе умножение не будет работать корректно. 
  > Здесь и далее, чтобы узнать знак числа, смотрим на значение первого бита в его двоичном представлении - здесь, если находится 0 - число неотрицательное, иначе - отрицательное(числа представлены в доп коде) То есть, смотрим (number >> (integer_size + fractional_size - 1)) % 2
  
  Далее производим умножение полученных положительных чисел, перед этим расширяя границы диапазона с помощью каста к (uint64_t), для того чтобы избежать переполнения. После этого у получившегося числа нам нужно округлить fractional_size разрядов справа. Округление делаем с помощью функции Round. В данном случае divider - 2 в степени fractional_size, т.к нам надо округлить ровно fractional_size разрядов справа.

  > A = a *  2 ** m
  >
  > B = b *  2 ** m
  >
  > A * B = a * b * 2** 2m / 2**m = с * 2 ** m
  >
  > m - кол-во битов на дробную часть
  >
  > a - настоящее дробное число, А - то как мы храним его в uint-е.
  
  Теперь, если требуется, переводим число в отрицательное с помощью Negation(до этого мы запомнили знак).

  После этого нужно взять по модулю число, срезав integer_size разрядов слева(модулярная арифметика делается после операции округления в методе DoOperation). 
 
 * **Деление**
  Не забываем обработать случай деления на ноль - исключение "division by zero"
  Большинство шагов делаются по аналогии с умножением - запоминаем знак, приводим числа к положительному виду. Далее сдвигаем первое число на fractional_size разрядов вправо, и делим его на второе сразу с поомщью функции округления, в данном случае divider - второе число.
   > A = a * 2 ** m 
   >
   > B = b * 2 ** m
   >
   > A / B = (a * 2 ** m / b * 2 ** m) * 2 ** m = a / b * 2 ** mm= c * 2 ** m
   
   Теперь, если требуется, переводим число в отрициательное, позже в DoOperation выполняется модулярная арифметика.


#### Вывод числа

Вывод числа выполняется с помощью метода **PrintNumber**.

Для начала, запоминаем знак(как найти знак рассматривается выше, в описании работы умножения) и при надобности переводим число в положительное при помощи Negation.

Чтобы найти целую часть - нужно воспользоваться целочисленным делением числа на 2 ** fractional_size. 

Чтобы найти дробную часть, для начала срезаем integer_size битов слева(нам нужно оставить только fractional_size младших битов). После этого умножаем получившееся число на 1000(т.к нам нужно вывести 3 цифры после точки) и закидываем в функцию Round, здесь в качестве divider выступает 2 ** fractional_size.

 После этого так же обрабатываем несколько крайних случаев: если после округления и дробная и целая часть равны нулю, изменим знак выражения на положительный, а если после округления дробная часть стала равна 1000, перенесем этот разряд в целую и добавим к ней единицу, а дробную занулим. 

 Выводим получившиеся значения.

# Плавающая точка

Программа для работы с числами в формате плавающей точке была реализована с помощью класса **FloatingPointArithmetic** и структуры **FloatingNumber**.

## Структура FloatingNumber

### Поля структуры

* **Поля хранящие число**
В данной структуре хранится число в формате плавающей точки, разбитое отдельно на 3 поля - знак(**is_negative**), мантисса(**mantissa**) и эспонента(**exponent**).
* **is_null** - флаг, показывающий является ли число нулем
  > Нам нужно хранить данную переменную, так как далее в данной реализации мы в конструкторе сразу нормализуем денормализованные числа. И если мы каждый раз будем узнавать является ли нулем  число сравнивая его мантиссу с нулем и экпоненту с min_exponent мы можем перепутать ноль и денормализованное число в виде 1 * 2 ** -(min_exponent)
* **format** - формат числа, half 'h' или single 'f'

* **"Константы", зависящие от формата(single/half)**
  > под константами здесь и далее подуразумевается не const в действительности как он представлен в языке С++, а некоторые нужные для вычислений значения, зависящие от формата.
  - **mantissa_size** - кол-во битов под мантиссу - в half = 10, в single = 23.
  - **exponent_size** - кол-во битов под экспоненту - в half = 5, в single = 8.
  -  **exponent_shift** - сдвиг настоящей экспоненты от ее закодированной версии - в half = 15, в single = 127.
  > экспонента в числах с плавающей точкой хранится в формате со сдвигом. Находим этот сдвиг по формуле 
  >> (2 ** n - 1) / 2 с округлением вниз
  - **max_exponent** - экспонента со сдвигом, которая закодирована как все единицы. Нам нужна эта переменная для удобства вычисления далее - нам часто нужно будет узнавать тип числа. Для half = 16, для single = 128.
  - **min_exponent** - экспонента со сдвигом, которая закодирована как все нули. Для half = -15, для single = -127.
* **rounding_type** - тип округления

### Конструкторы структуры

Основной конструктор принимает число в uint32_t являющееся битовым представлением вводного числа, а так же формат числа и тип округления.

- Если нужно, изменяем константы формата с помощью функции FixFormat.

- Достаем из числа знак экспоненту и мантиссу с помощью сдвигов.

> Число в формате half хранится как 1 бит на знак, после 5 битов на экспоненту, после 10 битов на мантиссу. В формате single - 1, 8, 23 в том же порядке.

- Если число является нулем, с

- После, если нужно, то есть если входное число является **денормализованным**, - нормализуем число для удобства работы с ним при операциях. **Нормализация** - поиск первой значащей единицы, и сдвиг числа с уменьшением степени, пока число не будет в формате 1.___

> **Денормализованные числа** - числа, у которых экспонента - все нули, мантисса - не ноль. В таких числах подуразумевается минимальная степень нормального числа(для half - -14, для single = -126), а перед точкой подуразумевается не 1. как в нормальных числах, а ноль.

Так же есть вспомогательный конструктор, который задает корректные константы формата и тип округления, но оставляет пустыми поля мантиссы и экспоненты. Он понадобится нам для обработки исключений далее.

### Методы структуры

#### Методы для определения типа числа

В операциях и при выводе будет требоваться знать тип числа. Есть 5 типов: нормальное, денормализованное, бесконечность, ноль и NaN.

- **IsInfinity**
Проверяет, равна ли экспонента max_exponent, и нулевая ли мантисса. В данном случае число является бесконечностью.
> бесконечность может получиться, например, при делении числа на ноль, либо при переполнении в некоторый случаях округления. Бесконечности работают по математическим правилам.

- **IsNan**
Проверяет, равна ли экспонента max_exponent, и ненулевая ли мантисса. В данном случае число является NaN-ом.
> NaN получается как результат некорректной математической операции, как, например, деления нуля на ноль.

- **IsNull**
Проверяет, является ли число нулем, смотря на флаг is_null в поле структуры.

#### Методы для задания число в случае исключения

- **MakeInfinity, MakeNan, MakeNull** 
  Задают число по правилам выше. Например, MakeInfinity ставит в значение экспоненты max_exponent, а в мантиссу 0.
- **MakeMinFinite, MakeMaxFinite**
  Понадобятся для работы с переполнениями и недоборами. MakeMaxFinite ставит в поля структуры числа соответствующие наибольшему возможно представимому нормальному числу, MakeMinFinite - наименьшему представимому денормализованному числу.
- **FixOverflow**  
  Вызывается в случае переполнения экспоненты. В такой ситуации конечный результат зависит от округления. 
 * при округлении к нулю в случае переполнения результатом считается наибольшее представимое нормальное число(по модулю)
  * при округлении к ближайшему, четному результат - бесконечность
  * при округлении к +бесконечности положительные числа дают результат бесконечность, а отрицательные - наибольшее представимое число(по модулю)
  * при округлении к -бесконечности - по аналогии с пунктом выше, но наоборот
* **FixUnderflow** 
  Вызывается в случае недобора экспоненты.
   * при округлении к нулю результатом считается ноль.
   * при округлении к ближайшему, четному смотрится ближайшее число, оно окажется либо нулем, либо минимальным представимым денормализованным числом. В случае когда ближайшего нет, выбираем ноль, так как минимальное представимое денормализованное число в последнем бите содержит единицу.
   * при округлении к +бесконечности положительное число дает результат - минимальное представимое денормализованное, а отрицательное - ноль.
   * при округлении к -бесконечности - наоборот.
  
#### Вспомогательные методы
  
  * **IsNegative, ChangeSign**
 Помогают во время операций быстро узнать/изменить знак числа.
 * **GetMantissa** 
  Помогает достать мантиссу вместе с незакодированной единицей для операций.

#### Метод для вывода числа

**PrintNumber** 

  - Чтобы вывести число, сначала проверяем его тип, обрабатывая краевые случаи(inf, nan, ноль). 
  - Не забываем про знак
  - Выводим его при помощи printf
  > Для красивого вывода нужн добрать количество битов мантиссы до кратного четырем, поэтому в half добираем до 12 с помощью докидывания двух нулей справа, в single добираем до 24 с помощью одного нуля.

## Класс FloatingPointArithmetic

> Структура данного класса, работает, в целом, так же как и в FixedPointArithmetic. Поэтому ниже не будет рассказываться про парсинг и округление - они были рассказаны выше.

### Метод для нормализации - Normalization

Главная функция, которая применяется после всех операций. Она либо нормализует число, либо приводит его к представимому в данном формате виду(обработка Overflow, Underflow).

Основная цель данной функции - найти первую значащую единицу(делается с помощью цикла). Она гарантированно существует, так как все случаи с нулями мы обрабатываем до операций. Далее, если требуется(после единицы стоит меньше чем mantissa_size знаков), единица сдвигается влево, а экспонента уменьшается.

Индекс первой единицы point_shift - это также то место, куда нужно поставить точку. И так как(представим, условимся) число приходит нам в эту функцию с точкой в самом конце(целое), мы прибавляем к значению экспоненты значение point_shift, тем самым ставля точку в нужное место и получая корректное значение экспоненты.

Далее в зависимости от значения экспоненты может возникнуть ситцация переполнения/ндобора, обрабатываем их с помощью вышеописанных методов FixUnderflow и FixOverflow.

Также может возникнуть степень денормализованного числа(<= min_exponent) - в таком случае при округлении далее нам нужно округлить еще на denormal_digits = (min_exponent - exponent + 1) - т.к иначе у денормализованного числа будет точность выше, чем она должна быть на самом деле.

Далее округляем ненужные разряды(должна остаться ровно единица и mantissa_size битов после нее). 

Не забудем обработать случаи, когда после округления число перешло за разряд первой единицы, в таком случае нужно увеличить экспоненту на один и сдвинуть мантиссу вправо( в таком случае не нужно округлять тк такие случаи возникают только при 1.111 -> 10.000, т.е все разряды мантиссы после единицы будут нулями). В том числе, в такой ситуации может возникнуть переполнение, что нужно проверить.

После этого, если требуется, сдвигаем мантиссу вправо на denormal_bits битов(т.к если мы округлили их для денормализованных мы должны их занулить)

И наконец, заполняем получившиеся мантиссу(кроме первой единицы) и экспоненту в result.

### Операции

> Так же как и в FixedPointArithmetic, операции обрабатываются единой функцией DoOperation. Если одно из чисел является NaN-ом, нет смысла проводить операцию - NaN на любую операцию возвращает NaN. Поэтому в таком случае считает результат NaN-ом и сразу переходим к выводу.

#### Умножение(метод Multiplication)

Начинаем с обработки краевых случаев.
* умножение бесконечности на ноль дает NaN
* умножение бесконечности на любое ненулевое число дает бесконечность
* умножение нуля на любое конечное число дает ноль

Знак и для краевых(кроме NaN, у него нет знака) и для нормальных случаев определяется как xor знаков первого и второго числа.

Далее достаем настоящие значения мантиссы обоих чисел(со значащей единицей) и перемножаем их. Запоминаем экспоненту получившегося как сумму экспонент двух чисел минус 2 размера мантиссы (мы представляем, что точку в данном числе будто бы перенесли в конец)

Запускаем функию нормализации.

#### Деление(метод Division)

Так же как и в умножении, начинаем с обработки краевых случаев.
* деление нуля на ноль дает NaN
* деление бесконечности на бесконечность дает NaN
* деление бесконечности на любое конечное число дает бесконечность
* деление любого числа на ноль дает бесконечность
* деление нуля на любое число дает ноль
* деление любого конечного числа на бесконечность дает ноль

Знак получаем аналогично умножению.

Получаем мантиссы и первую мантиссу сдвигаем вправо на (mantissa_size + 1) битов. Это позволит сохранить максимальную точность далее при делении. Экспоненте ставим в значение разницу первой и второй вычесть дополнительно наш сдвиг на (mantissa_size + 1) битов.

После этого, чтобы сохранить точность в делении и округлить один раз вместо двух, используются дополнительные аргументы в нормализации. Так, сначала в нормализации мы считаем место значащей единицы, как она стояла бы если бы мы разделили бы первую мантиссу на вторую с округлением к нулю, и уже после сразу округляем первую мантиссу, где в качесте divider выступает вторая мантисса * 2 в степени кол-ва битов, которые нам нужно округлить для нормализации.

#### Сложение и вычитание(методы Addition и Subtracton)

> Вычитание выполняется через сложение путем замены знака второго числа на противоположный.

Обработка исключений 
* сложение двух бесконечностей разного знака дает NaN
* сложение бесконечности с любым числом(кроме противоположной ей по знаку бесконечности) дает ту же бесконечность
* сложение двух одинаковых пчисел противоположных по знаку дает 0(но если тип округления к минус бесконечности - дает -0)
* сложение ноля с любым числом дает это число
  
Достаем из обоих чисел все их параметры. Далее будем считать что экспонента первого числа больше чем экспонента второго - для этого сделаем swap, если нужно.

Заметим, что сложение производится над очень большим и очень маленьким по сравнению друг с другом числом можно вынести в отдельный случай - тут результат и повлияет ли маленькое число на большее будеть зависить от округления. Т.е случаи, когда экспоненты двух чисел отличаются на более чем mantissa_size + 2. Все случаи для разных округлений проверяются в if-aх, позже проводится нормализация.

Путем того, что мы вынесли в отдельный случай сильную разницу экспонент, теперь мы можем просто привести экспоненту первого числа к экспоненте второго числа постепенно сдвигая первое число вправо. И мы избежим переполнения uint64_t, так как экспоненты отличаются не более чем на mantissa_size + 2.

И теперь мы можем произвести нужную арифметическую операцию. Когда оба числа одного и того же знака - требуется сложение, иначе - вычитание. Причем при вычитании всегда будем вычитать из большей мантиссы наименьшую(для избежания проблем), так же не будем забывать про правильность знака.

Запускаем нормализацию.